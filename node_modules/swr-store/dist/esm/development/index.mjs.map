{
  "version": 3,
  "sources": ["../../../src/global.ts", "../../../src/cache/reactive-cache.ts", "../../../src/cache/mutation-cache.ts", "../../../src/cache/revalidation-cache.ts", "../../../src/default-config.ts", "../../../src/is-client.ts", "../../../src/retry.ts", "../../../src/create-swr-store.ts"],
  "sourcesContent": ["import { dequal } from 'dequal/lite';\nimport {\n  getMutation,\n  MutationListener,\n  MutationResult,\n  setMutation,\n  subscribeMutation,\n} from './cache/mutation-cache';\nimport {\n  setRevalidation,\n} from './cache/revalidation-cache';\n\nexport function trigger(\n  key: string,\n  shouldRevalidate = true,\n): void {\n  setRevalidation(key, shouldRevalidate);\n}\n\nexport function mutate<T>(\n  key: string,\n  data: MutationResult<T>,\n  shouldRevalidate = true,\n  compare: (a: T, b: T) => boolean = dequal,\n): void {\n  setRevalidation(key, shouldRevalidate);\n\n  const current = getMutation<T>(key);\n\n  if (\n    current\n    && current.result.status === 'success' && data.status === 'success'\n    && compare(current.result.data, data.data)\n  ) {\n    current.timestamp = Date.now();\n    return;\n  }\n\n  setMutation(key, {\n    result: data,\n    timestamp: Date.now(),\n    isValidating: false,\n  });\n}\n\nexport function subscribe<T>(\n  key: string,\n  listener: MutationListener<T>,\n): () => void {\n  const wrappedListener: MutationListener<T> = (value) => {\n    listener(value);\n  };\n  return subscribeMutation(key, wrappedListener);\n}\n", "export type ReactiveCacheListener<T> = (value: T) => void;\nexport interface ReactiveCacheRef<T> {\n  value: T;\n}\n\nexport interface ReactiveCache<T> {\n  cache: Map<string, ReactiveCacheRef<T>>;\n  subscribers: Map<string, Set<ReactiveCacheListener<T>>>;\n}\n\nexport function createReactiveCache<T>(): ReactiveCache<T> {\n  return {\n    cache: new Map(),\n    subscribers: new Map(),\n  };\n}\n\nexport function createReactiveCacheRef<T>(\n  cache: ReactiveCache<T>,\n  key: string,\n  value: T,\n): ReactiveCacheRef<T> {\n  const currentRef = cache.cache.get(key);\n  if (currentRef) {\n    return currentRef;\n  }\n  const newRef: ReactiveCacheRef<T> = {\n    value,\n  };\n  cache.cache.set(key, newRef);\n  return newRef;\n}\n\nexport function subscribeReactiveCache<T>(\n  cache: ReactiveCache<T>,\n  key: string,\n  listener: ReactiveCacheListener<T>,\n): () => void {\n  let subscribers = cache.subscribers.get(key);\n  if (!subscribers) {\n    subscribers = new Set();\n    cache.subscribers.set(key, subscribers);\n  }\n  subscribers.add(listener);\n\n  return () => {\n    if (subscribers) {\n      subscribers.delete(listener);\n    }\n  };\n}\n\nexport function setReactiveCacheValue<T>(\n  cache: ReactiveCache<T>,\n  key: string,\n  value: T,\n  notify = true,\n): void {\n  const currentRef = createReactiveCacheRef(cache, key, value);\n  currentRef.value = value;\n\n  if (notify) {\n    let subscribers = cache.subscribers.get(key);\n    if (!subscribers) {\n      subscribers = new Set();\n      cache.subscribers.set(key, subscribers);\n    }\n    for (const listener of subscribers.keys()) {\n      listener(value);\n    }\n  }\n}\n\nexport function getReactiveCacheListenerSize<T>(\n  cache: ReactiveCache<T>,\n  key: string,\n): number {\n  const result = cache.subscribers.get(key);\n  if (result) {\n    return result.size;\n  }\n  return 0;\n}\n", "import {\n  createReactiveCache,\n  getReactiveCacheListenerSize,\n  ReactiveCacheListener,\n  setReactiveCacheValue,\n  subscribeReactiveCache,\n} from './reactive-cache';\n\nexport interface MutationPending<T> {\n  data: Promise<T>;\n  status: 'pending';\n}\nexport interface MutationSuccess<T> {\n  data: T;\n  status: 'success';\n}\nexport interface MutationFailure {\n  data: any;\n  status: 'failure';\n}\nexport type MutationResult<T> =\n  | MutationPending<T>\n  | MutationSuccess<T>\n  | MutationFailure;\n\nexport interface Mutation<T> {\n  result: MutationResult<T>;\n  timestamp: number;\n  isValidating: boolean;\n}\n\nexport const MUTATION_CACHE = createReactiveCache<Mutation<any>>();\n\nexport type MutationListener<T> = ReactiveCacheListener<Mutation<T>>;\n\nexport function subscribeMutation<T>(\n  key: string,\n  listener: MutationListener<T>,\n): () => void {\n  return subscribeReactiveCache(MUTATION_CACHE, key, listener);\n}\n\nexport function setMutation<T>(\n  key: string,\n  value: Mutation<T>,\n): void {\n  setReactiveCacheValue(MUTATION_CACHE, key, value);\n}\n\nexport function getMutation<T>(\n  key: string,\n): Mutation<T> | undefined {\n  const result = MUTATION_CACHE.cache.get(key);\n  if (result) {\n    return result.value;\n  }\n  return undefined;\n}\n\nexport function getMutationListenerSize(\n  key: string,\n): number {\n  return getReactiveCacheListenerSize(MUTATION_CACHE, key);\n}\n", "import {\n  createReactiveCache,\n  ReactiveCacheListener,\n  setReactiveCacheValue,\n  subscribeReactiveCache,\n} from './reactive-cache';\n\nexport const REVALIDATION_CACHE = createReactiveCache<boolean>();\n\nexport type RevalidationListener = ReactiveCacheListener<boolean>;\n\nexport function subscribeRevalidation(\n  key: string,\n  listener: RevalidationListener,\n): () => void {\n  return subscribeReactiveCache(REVALIDATION_CACHE, key, listener);\n}\n\nexport function setRevalidation(\n  key: string,\n  value: boolean,\n  notify = true,\n): void {\n  setReactiveCacheValue(REVALIDATION_CACHE, key, value, notify);\n}\n\nexport function getRevalidation(\n  key: string,\n): boolean | undefined {\n  const result = REVALIDATION_CACHE.cache.get(key);\n  if (result) {\n    return result.value;\n  }\n  return undefined;\n}\n", "import { dequal } from 'dequal/lite';\nimport { SWRStoreExtendedOptions } from './types';\n\nfunction defaultKey<P extends any[] = []>(...args: P): string {\n  return JSON.stringify(args);\n}\n\nconst DEFAULT_CONFIG: SWRStoreExtendedOptions<any, any> = {\n  revalidateOnFocus: false,\n  revalidateOnNetwork: false,\n  revalidateOnVisibility: false,\n  refreshWhenHidden: false,\n  refreshWhenBlurred: false,\n  refreshWhenOffline: false,\n  freshAge: 2000,\n  staleAge: 30000,\n  key: defaultKey,\n  compare: dequal,\n  maxRetryInterval: 5000,\n};\n\nexport default DEFAULT_CONFIG;\n", "const IS_CLIENT = typeof window !== 'undefined'\n  && typeof window.document !== 'undefined'\n  && typeof window.document.createElement !== 'undefined';\n\nexport default IS_CLIENT;\n", "interface RetryOptions {\n  count?: number;\n  interval: number;\n}\n\ninterface Resolvable<T> {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: any) => void;\n}\n\nexport interface Retry<T> {\n  resolvable: Resolvable<T>;\n  cancel: () => void;\n}\n\nfunction createResolvable<T>(): Resolvable<T> {\n  let resolve: Resolvable<T>['resolve'] = () => {\n    //\n  };\n  let reject: Resolvable<T>['reject'] = () => {\n    //\n  };\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve,\n    reject,\n  };\n}\n\nexport default function retry<T>(supplier: () => Promise<T>, options: RetryOptions): Retry<T> {\n  let alive = true;\n  let schedule: number;\n\n  const resolvable = createResolvable<T>();\n\n  const backoff = (timeout = 10, count = 0) => {\n    const handle = (reason: any) => {\n      if (!alive || (typeof options.count === 'number' && options.count <= count)) {\n        resolvable.reject(reason);\n      } else {\n        schedule = window.setTimeout(() => {\n          backoff(Math.max(10, Math.min(options.interval, timeout * 2)), count + 1);\n        }, timeout);\n      }\n    };\n\n    try {\n      supplier().then(resolvable.resolve, handle);\n    } catch (reason) {\n      handle(reason);\n    }\n  };\n\n  backoff();\n\n  return {\n    resolvable,\n    cancel: () => {\n      if (schedule) {\n        clearTimeout(schedule);\n      }\n      alive = false;\n    },\n  };\n}\n", "import {\n  getMutation,\n  getMutationListenerSize,\n  MutationPending,\n  MutationResult,\n  setMutation,\n} from './cache/mutation-cache';\nimport {\n  setRevalidation,\n  subscribeRevalidation,\n} from './cache/revalidation-cache';\nimport DEFAULT_CONFIG from './default-config';\nimport {\n  mutate,\n  subscribe,\n  trigger,\n} from './global';\nimport IS_CLIENT from './is-client';\nimport retry, { Retry } from './retry';\nimport {\n  SWRFullOptions,\n  SWRGetOptions,\n  SWRStore,\n  SWRStoreOptions,\n} from './types';\n\nlet index = 0;\n\nfunction getIndex() {\n  const current = index;\n  index += 1;\n  return current;\n}\n\nconst retries = new Map<string, Retry<any>>();\n\nconst { assign } = Object;\n\nfunction revalidate<T, P extends any[] = []>(\n  fullOpts: SWRFullOptions<T, P>,\n  args: P,\n  opts?: SWRGetOptions<T>,\n): MutationResult<T> {\n  const defaultRevalidateOptions: SWRGetOptions<T> = {\n    shouldRevalidate: true,\n    initialData: fullOpts.initialData,\n    hydrate: false,\n  };\n  const revalidateOptions: SWRGetOptions<T> = assign(\n    {},\n    defaultRevalidateOptions,\n    opts,\n  );\n  // Parse key\n  const generatedKey = fullOpts.key(...args);\n\n  // Capture timestamp\n  const timestamp = Date.now();\n\n  // Get current mutation\n  let currentMutation = getMutation<T>(generatedKey);\n\n  // Hydrate mutation\n  if (!currentMutation && revalidateOptions.initialData) {\n    currentMutation = {\n      result: {\n        data: revalidateOptions.initialData,\n        status: 'success',\n      },\n      timestamp,\n      isValidating: false,\n    };\n\n    if (revalidateOptions.hydrate) {\n      setMutation(generatedKey, currentMutation);\n    }\n  }\n\n  if (currentMutation) {\n    if (!revalidateOptions.shouldRevalidate) {\n      return currentMutation.result;\n    }\n    // If mutation is still fresh, return mutation\n    if (currentMutation.timestamp + fullOpts.freshAge > timestamp) {\n      return currentMutation.result;\n    }\n\n    // We have to assume that if the request is no longer fresh\n    // and the request is still pending, we need to cancel it\n    // specially if it's retrying.\n    if (currentMutation.result.status === 'pending') {\n      const previousRetry = retries.get(generatedKey);\n\n      if (previousRetry) {\n        previousRetry.cancel();\n      }\n    }\n  }\n\n  // Perform fetch\n  const pendingRetry = retry(() => fullOpts.get(...args), {\n    count: fullOpts.maxRetryCount,\n    interval: fullOpts.maxRetryInterval,\n  });\n\n  // Set current retry\n  retries.set(generatedKey, pendingRetry);\n\n  const pendingData = pendingRetry.resolvable.promise;\n\n  // Capture result\n  const result: MutationPending<T> = {\n    data: pendingData,\n    status: 'pending',\n  };\n\n  // Watch for promise resolutions\n  // to update cache data\n  pendingData.then(\n    (data) => {\n      const mutation = getMutation<T>(generatedKey);\n\n      const shouldUpdate = (): boolean => {\n        // Case 1: There's no mutation\n        if (mutation == null) {\n          return true;\n        }\n\n        // Case 2: Timestamp expired\n        if (mutation.timestamp > timestamp) {\n          return false;\n        }\n\n        // Case 3: There's a stale data\n        if (mutation.result.status === 'success') {\n          // Deep compare stale data\n          return !fullOpts.compare(\n            mutation.result.data,\n            data,\n          );\n        }\n\n        // Always update\n        return true;\n      };\n\n      if (shouldUpdate()) {\n        setMutation(generatedKey, {\n          result: {\n            data,\n            status: 'success',\n          },\n          timestamp: (mutation && mutation.timestamp) ? mutation.timestamp : Date.now(),\n          isValidating: false,\n        });\n      }\n    },\n    (data) => {\n      const mutation = getMutation<T>(generatedKey);\n\n      const shouldUpdate = (): boolean => {\n        // Case 1: There's no mutation\n        if (mutation == null) {\n          return true;\n        }\n\n        // Case 2: Timestamp expired\n        if (mutation.timestamp > timestamp) {\n          return false;\n        }\n\n        // Always update\n        return true;\n      };\n\n      if (shouldUpdate()) {\n        setMutation(generatedKey, {\n          result: {\n            data,\n            status: 'failure',\n          },\n          timestamp: (mutation && mutation.timestamp) ? mutation.timestamp : Date.now(),\n          isValidating: false,\n        });\n      }\n    },\n  );\n\n  // If there's an existing mutation\n  // and mutation is stale\n  // update timestamp and return\n  if (\n    currentMutation\n    && currentMutation.timestamp + fullOpts.freshAge + fullOpts.staleAge > timestamp\n  ) {\n    // Updating this means that the freshness or the staleness\n    // of a mutation resets\n    currentMutation.timestamp = timestamp;\n    currentMutation.isValidating = true;\n    return currentMutation.result;\n  }\n\n  // Otherwise, set the new mutation\n  setMutation(generatedKey, {\n    result,\n    timestamp,\n    isValidating: true,\n  });\n\n  return result;\n}\n\ntype Cleanup = () => void;\ntype Cleanups = Cleanup[];\ntype Subscribe = () => Cleanup;\n\n\n// This lazy registration allows manageable\n// global source subscriptions by performing\n// reference-counting.\nfunction lazyRegister<T, P extends any[] = []>(\n  cleanups: Map<string, Cleanups>,\n  generatedKey: string,\n  fullOpts: SWRFullOptions<T, P>,\n  args: P,\n) {\n  // If there are listeners, it means\n  // that the store has already made subscriptions\n  if (getMutationListenerSize(generatedKey) > 0) {\n    return;\n  }\n\n  // Create cleanup stack\n  const currentCleanups: Cleanups = [];\n\n  const subscription = (sub: Subscribe) => {\n    currentCleanups.push(sub());\n  };\n\n  const onRevalidate = () => {\n    setRevalidation(generatedKey, true);\n  };\n  subscription(() => {\n    const innerRevalidate = (flag: boolean) => {\n      revalidate(fullOpts, args, {\n        shouldRevalidate: flag,\n      });\n    };\n    return subscribeRevalidation(generatedKey, innerRevalidate);\n  });\n\n  // Only register on client-side\n  if (IS_CLIENT) {\n    // Register polling interval\n    if (fullOpts.refreshInterval != null) {\n      if (fullOpts.refreshWhenBlurred) {\n        subscription(() => {\n          let interval: undefined | number;\n\n          const enter = () => {\n            window.clearInterval(interval);\n            interval = window.setInterval(onRevalidate, fullOpts.refreshInterval);\n          };\n          const exit = () => {\n            window.clearInterval(interval);\n            interval = undefined;\n          };\n\n          window.addEventListener('blur', enter, false);\n          window.addEventListener('focus', exit, false);\n\n          return () => {\n            window.removeEventListener('blur', enter, false);\n            window.removeEventListener('focus', exit, false);\n            window.clearInterval(interval);\n          };\n        });\n      }\n      if (fullOpts.refreshWhenOffline) {\n        subscription(() => {\n          let interval: undefined | number;\n\n          const enter = () => {\n            window.clearInterval(interval);\n            interval = window.setInterval(onRevalidate, fullOpts.refreshInterval);\n          };\n          const exit = () => {\n            window.clearInterval(interval);\n            interval = undefined;\n          };\n\n          window.addEventListener('offline', enter, false);\n          window.addEventListener('online', exit, false);\n\n          return () => {\n            window.removeEventListener('offline', enter, false);\n            window.removeEventListener('online', exit, false);\n            window.clearInterval(interval);\n          };\n        });\n      }\n      if (fullOpts.refreshWhenHidden) {\n        subscription(() => {\n          let interval: undefined | number;\n\n          const onVisibility = () => {\n            window.clearInterval(interval);\n            if (document.visibilityState === 'visible') {\n              interval = undefined;\n            } else {\n              interval = window.setInterval(onRevalidate, fullOpts.refreshInterval);\n            }\n          };\n\n          document.addEventListener('visibilitychange', onVisibility, false);\n\n          return () => {\n            document.removeEventListener('visibilitychange', onVisibility, false);\n            window.clearInterval(interval);\n          };\n        });\n      }\n      if (\n        !(fullOpts.refreshWhenHidden\n        || fullOpts.refreshWhenBlurred\n        || fullOpts.refreshWhenOffline)\n      ) {\n        subscription(() => {\n          const interval = window.setInterval(onRevalidate, fullOpts.refreshInterval);\n\n          return () => {\n            window.clearInterval(interval);\n          };\n        });\n      }\n    }\n\n    // Registers a focus event for revalidation.\n    if (fullOpts.revalidateOnFocus) {\n      subscription(() => {\n        window.addEventListener('focus', onRevalidate, false);\n\n        return () => {\n          window.removeEventListener('focus', onRevalidate, false);\n        };\n      });\n    }\n\n    // Registers a online event for revalidation.\n    if (fullOpts.revalidateOnNetwork) {\n      subscription(() => {\n        window.addEventListener('online', onRevalidate, false);\n\n        return () => {\n          window.removeEventListener('online', onRevalidate, false);\n        };\n      });\n    }\n\n    // Registers a visibility change event for revalidation.\n    if (fullOpts.revalidateOnVisibility) {\n      subscription(() => {\n        const onVisible = () => {\n          if (document.visibilityState === 'visible') {\n            onRevalidate();\n          }\n        };\n\n        window.addEventListener('visibilitychange', onVisible, false);\n\n        return () => {\n          window.removeEventListener('visibilitychange', onVisible, false);\n        };\n      });\n    }\n  }\n\n  cleanups.set(generatedKey, currentCleanups);\n}\n\nfunction lazyUnregister(\n  cleanups: Map<string, Cleanups>,\n  generatedKey: string,\n) {\n  if (getMutationListenerSize(generatedKey) === 0) {\n    const actualCleanups = cleanups.get(generatedKey);\n    if (actualCleanups) {\n      for (let i = 0, len = actualCleanups.length; i < len; i += 1) {\n        actualCleanups[i]();\n      }\n      cleanups.delete(generatedKey);\n    }\n  }\n}\n\nexport default function createSWRStore<T, P extends any[] = []>(\n  options: SWRStoreOptions<T, P>,\n): SWRStore<T, P> {\n  const fullOpts: SWRFullOptions<T, P> = assign({}, DEFAULT_CONFIG, options);\n  const cleanups = new Map<string, Cleanups>();\n\n  return {\n    id: `SWRStore-${getIndex()}`,\n    trigger: (args, shouldRevalidate = true) => {\n      const generatedKey = fullOpts.key(...args);\n      trigger(generatedKey, shouldRevalidate);\n    },\n    mutate: (args, data, shouldRevalidate = true, compare = fullOpts.compare) => {\n      const generatedKey = fullOpts.key(...args);\n      mutate(generatedKey, data, shouldRevalidate, compare);\n    },\n    // This function revalidates the mutation cache\n    // through reactive process\n    get: (args, opts) => revalidate(fullOpts, args, opts),\n    subscribe: (args, listener) => {\n      const generatedKey = fullOpts.key(...args);\n\n      // Setup lazy global registration\n      lazyRegister(cleanups, generatedKey, fullOpts, args);\n\n      const unsubscribe = subscribe(generatedKey, listener);\n      return () => {\n        unsubscribe();\n        // Attempt lazy unregistration\n        lazyUnregister(cleanups, generatedKey);\n      };\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["dequal"]
}
