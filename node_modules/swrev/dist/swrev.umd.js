(function(i,n){typeof exports=="object"&&typeof module<"u"?n(exports):typeof define=="function"&&define.amd?define(["exports"],n):(i=typeof globalThis<"u"?globalThis:i||self,n(i.swrev={}))})(this,function(i){"use strict";var X=Object.defineProperty;var $=(i,n,l)=>n in i?X(i,n,{enumerable:!0,configurable:!0,writable:!0,value:l}):i[n]=l;var d=(i,n,l)=>($(i,typeof n!="symbol"?n+"":n,l),l);class n{constructor(){d(this,"listeners",new Map)}subscribe(e,t){this.listeners.has(e)||this.listeners.set(e,[]),!this.listeners.get(e).includes(t)&&this.listeners.get(e).push(t)}unsubscribe(e,t){this.listeners.has(e)&&this.listeners.get(e).includes(t)&&(this.listeners.get(e).splice(this.listeners.get(e).indexOf(t),1),this.listeners.get(e).length===0&&this.listeners.delete(e))}emit(e,t){this.listeners.has(e)&&this.listeners.get(e).forEach(s=>s(t))}}const l={broadcast:!1},R={broadcast:!1};class b{constructor({data:e,expiresAt:t=null}){d(this,"data");d(this,"expiresAt");this.data=e,this.expiresAt=t}isResolving(){return this.data instanceof Promise}hasExpired(){return this.expiresAt===null||this.expiresAt<new Date}expiresIn(e){return this.expiresAt=new Date,this.expiresAt.setMilliseconds(this.expiresAt.getMilliseconds()+e),this}}class M{constructor(){d(this,"elements",new Map);d(this,"event",new n)}resolve(e,t){Promise.resolve(t.data).then(s=>{if(s==null)return this.remove(e);t.data=s,this.broadcast(e,s)})}get(e){return this.elements.get(e)}set(e,t){this.elements.set(e,t),this.resolve(e,t)}remove(e,t){const{broadcast:s}={...l,...t};s&&this.broadcast(e,void 0),this.elements.delete(e)}clear(e){const{broadcast:t}={...R,...e};if(t)for(const s of this.elements.keys())this.broadcast(s,void 0);this.elements.clear()}has(e){return this.elements.has(e)}subscribe(e,t){this.event.subscribe(e,t)}unsubscribe(e,t){this.event.unsubscribe(e,t)}broadcast(e,t){this.event.emit(e,t)}}const p={cache:new M,errors:new n,fetcher:async c=>{const e=await fetch(c);if(!e.ok)throw Error("Not a 2XX response.");return e.json()},fallbackData:void 0,loadInitialCache:!0,revalidateOnStart:!0,dedupingInterval:2e3,revalidateOnFocus:!0,focusThrottleInterval:5e3,revalidateOnReconnect:!0,reconnectWhen:(c,{enabled:e})=>e&&typeof window<"u"?(window.addEventListener("online",c),()=>window.removeEventListener("online",c)):()=>{},focusWhen:(c,{enabled:e,throttleInterval:t})=>{if(e&&typeof window<"u"){let s=null;const r=()=>{const o=Date.now();(s===null||o-s>t)&&(s=o,c())};return window.addEventListener("focus",r),()=>window.removeEventListener("focus",r)}return()=>{}},revalidateFunction:void 0},w={...p,force:!1},W={revalidate:!0,revalidateOptions:{...w},revalidateFunction:void 0},A={broadcast:!1};class K{constructor(e){d(this,"options");this.options={...p,...e}}get cache(){return this.options.cache}get errors(){return this.options.errors}async requestData(e,t){return await Promise.resolve(t(e)).catch(s=>{throw this.errors.emit(e,s),s})}resolveKey(e){if(typeof e=="function")try{return e()}catch{return}return e}clear(e,t){const s={...A,...t};if(e==null)return this.cache.clear(s);if(!Array.isArray(e))return this.cache.remove(e,s);for(const r of e)this.cache.remove(r,s)}async revalidate(e,t){if(!e)throw new Error("[Revalidate] Key issue: ${key}");const{fetcher:s,dedupingInterval:r}=this.options,{force:o,fetcher:h,dedupingInterval:a}={...w,fetcher:s,dedupingInterval:r,...t};if(o||!this.cache.has(e)||this.cache.has(e)&&this.cache.get(e).hasExpired()){const u=this.requestData(e,h),f=u.catch(()=>{});return this.cache.set(e,new b({data:f}).expiresIn(a)),await u}return this.getWait(e)}async mutate(e,t,s){if(!e)throw new Error("[Mutate] Key issue: ${key}");const{revalidate:r,revalidateOptions:o,revalidateFunction:h}={...W,...s};let a;if(typeof t=="function"){let u;if(this.cache.has(e)){const f=this.cache.get(e);f.isResolving()||(u=f.data)}a=t(u)}else a=t;return this.cache.set(e,new b({data:a})),r?await((h==null?void 0:h(e,o))??this.revalidate(e,o)):a}subscribeData(e,t){if(e){const s=r=>t(r);return this.cache.subscribe(e,s),()=>this.cache.unsubscribe(e,s)}return()=>{}}subscribeErrors(e,t){if(e){const s=r=>t(r);return this.errors.subscribe(e,s),()=>this.errors.unsubscribe(e,s)}return()=>{}}get(e){if(e&&this.cache.has(e)){const t=this.cache.get(e);if(!t.isResolving())return t.data}}getWait(e){return new Promise((t,s)=>{const r=this.subscribeData(e,a=>{if(r(),a!==void 0)return t(a)}),o=this.subscribeErrors(e,a=>{if(o(),a!==void 0)return s(a)}),h=this.get(e);if(h!==void 0)return t(h)})}subscribe(e,t,s,r){const{fetcher:o,fallbackData:h,loadInitialCache:a,revalidateOnStart:u,dedupingInterval:f,revalidateOnFocus:S,focusThrottleInterval:x,revalidateOnReconnect:T,reconnectWhen:F,focusWhen:L,revalidateFunction:g}={...this.options,...r},j=P=>(g==null?void 0:g(this.resolveKey(e),P))??this.revalidate(this.resolveKey(e),P),m=()=>j({fetcher:o,dedupingInterval:f}),v=a?this.get(this.resolveKey(e)):h??void 0,D=u?m():Promise.resolve(void 0),q=v?Promise.resolve(v):D;v&&(t==null||t(v));const O=t?this.subscribeData(this.resolveKey(e),t):void 0,C=s?this.subscribeErrors(this.resolveKey(e),s):void 0,I=L(m,{throttleInterval:x,enabled:S}),E=F(m,{enabled:T});return{unsubscribe:()=>{O==null||O(),C==null||C(),I==null||I(),E==null||E()},dataPromise:q,revalidatePromise:D}}}i.CacheItem=b,i.DefaultCache=M,i.DefaultSWREventManager=n,i.SWR=K,i.defaultCacheClearOptions=R,i.defaultCacheRemoveOptions=l,i.defaultClearOptions=A,i.defaultMutateOptions=W,i.defaultOptions=p,i.defaultRevalidateOptions=w,Object.defineProperty(i,Symbol.toStringTag,{value:"Module"})});
