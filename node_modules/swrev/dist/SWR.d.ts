import { SWRCache, CacheClearOptions } from './cache';
import { SWREventManager } from './events';
import { SWRKey } from './key';
import { SWROptions, SWRRevalidateOptions, SWRFetcher, SWRMutateOptions } from './options';
/**
 * Determines how a function state value looks like.
 */
export type SWRFunctionStateValue<D> = (state: D | undefined) => D;
/**
 * Determines how a SWR mutate value looks like.
 */
export type SWRMutateValue<D> = D | SWRFunctionStateValue<D>;
/**
 * Stale While Revalidate
 */
export declare class SWR {
    /**
     * Stores the options of the SWR.
     */
    options: SWROptions;
    /**
     * Creates a new instance of SWR.
     */
    constructor(options?: Partial<SWROptions>);
    /**
     * Gets the cache of the SWR.
     */
    protected get cache(): SWRCache;
    /**
     * Gets the cache of the SWR.
     */
    protected get errors(): SWREventManager;
    /**
     * Requests the data using the provided fetcher.
     */
    protected requestData<D, E extends Error = Error>(key: SWRKey, fetcher: SWRFetcher<D>): Promise<D>;
    /**
     * Resolves the given to a SWRKey or undefined.
     */
    protected resolveKey(key: SWRKey | undefined | (() => SWRKey | undefined)): SWRKey | undefined;
    /**
     * Clear the specified keys from the cache. If no keys
     * are specified, it clears all the cache keys.
     */
    clear(keys?: SWRKey | SWRKey[] | null, options?: Partial<CacheClearOptions>): void;
    /**
     * Revalidates the key and mutates the cache if needed.
     */
    revalidate<D = any>(key: SWRKey | undefined, options?: Partial<SWRRevalidateOptions<D>>): Promise<D>;
    /**
     * Mutates the data of a given key with a new value.
     * This is used to replace the cache contents of the
     * given key manually.
     */
    mutate<D = any>(key: SWRKey | undefined, value: SWRMutateValue<D>, options?: Partial<SWRMutateOptions<D>>): Promise<D>;
    /**
     * Gets the data of the given key. Keep in mind
     * this data will be stale and revalidate in the background
     * unless specified otherwise.
     */
    subscribeData<D = any>(key: SWRKey | undefined, onData: (value: D) => any): () => void;
    /**
     * Subscribes to errors on the given key.
     */
    subscribeErrors<E = Error>(key: SWRKey | undefined, onError: (error: E) => any): () => void;
    /**
     * Gets the current cached data of the given key.
     * This does not trigger any revalidation nor mutation
     * of the data.
     * - If the data has never been validated
     * (there is no cache) it will return undefined.
     * - If the item is pending to resolve (there is a request
     * pending to resolve) it will return undefined.
     */
    get<D = any>(key: SWRKey | undefined): D | undefined;
    /**
     * Gets an element from the cache. The difference
     * with the get is that this method returns a promise
     * that will resolve the the value. If there's no item
     * in the cache, it will wait for it before resolving.
     */
    getWait<D = any, E = Error>(key: SWRKey | undefined): Promise<D>;
    /**
     * Use a SWR value given the key and
     * subscribe to future changes.
     */
    subscribe<D = any, E = Error>(key: SWRKey | undefined | (() => SWRKey | undefined), onData?: (value: D) => void, onError?: (error: E) => void, options?: Partial<SWROptions<D>>): {
        unsubscribe: () => void;
        dataPromise: Promise<D> | Promise<undefined>;
        revalidatePromise: Promise<D> | Promise<undefined>;
    };
}
